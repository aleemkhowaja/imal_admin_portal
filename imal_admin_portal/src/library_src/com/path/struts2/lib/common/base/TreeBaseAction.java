package com.path.struts2.lib.common.base;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.struts2.json.JSONException;
import org.codehaus.jackson.annotate.JsonAutoDetect.Visibility;
import org.codehaus.jackson.annotate.JsonMethod;
import org.codehaus.jackson.map.DeserializationConfig;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.JsonParser;

import com.path.lib.common.exception.BaseException;
import com.path.lib.common.util.StringUtil;
import com.path.struts2.json.PathJSONUtil;
import com.path.vo.common.tree.GraphicalLinkCO;
import com.path.vo.common.tree.GraphicalNode;
import com.path.vo.common.tree.GraphicalNodeCO;
import com.path.vo.common.tree.GraphicalPattern;
import com.path.vo.common.tree.GraphicalVertice;
import com.path.vo.common.tree.TreeNode;
import com.path.vo.common.tree.TreeNodeCO;

/**
 * Copyright 2015, Path Solutions Path Solutions retains all ownership rights to
 * this source code </br>
 * 
 * <strong>TreeBaseAction.java</strong> used to implement the functionality of
 * the jQuery jsTree and joint Graphical Tree
 * 
 * @author Khaledhussein
 * 
 */
@SuppressWarnings("serial")
public class TreeBaseAction extends BaseAction
{

    // The struts result for the Tree tag
    protected final static String JSON_TREE = "JSON_TREE";

    // The array of nodes that will generate the tree
    private List<TreeNode> nodes = new ArrayList<TreeNode>();

    // The object that contains nodes of graphical tree
    private String graphCells;
    // default state of the all nodes open/closed
    private String defualtNodesState = TreeNode.NODE_STATE_OPEN;

    /**
     * This method responsible of generating the tree for <psjt:tree /> tag
     * 
     * @param treeNodeCOs
     * @return
     */
    private List<TreeNode> generateTree(List<TreeNodeCO> treeNodeCOs)
    {
	Map<String, TreeNode> nodesMap = new HashMap<String, TreeNode>();

	TreeNode node = null;

	// Fill all the nodes in the nodesMap
	for(TreeNodeCO treeNodeCO : treeNodeCOs)
	{
	    node = new TreeNode(treeNodeCO.getNodeCode(), treeNodeCO.getParentNodeCode(), treeNodeCO.getIcon(),
		    returnKeyTrans(treeNodeCO.getTitle()),treeNodeCO.getNodeOrder());
	    // NodeId is autogenerated
	    node.setId(autoGenerateNodeID());

	    // hasChild to state that the node has children
	    node.setHasChild(false);

	    // aChild to state that the node is a child of a node
	    node.setaChild(false);

	    // Support checking of the node on load
	    node.setChecked(treeNodeCO.getChecked());
	    
	    // Support disabling of the node on load
	    node.setDisabled(treeNodeCO.getDisabled());
	    
	    // Support children disabled of the node on load
	    node.setChildrenDisabled(treeNodeCO.getChildrenDisabled());
	    
	    // adding Custom Attributes that added by DEV to each Node
	    if(treeNodeCO.getCustomAttributes() != null)
	    {
		node.addAdditionalCustomAttr(treeNodeCO.getCustomAttributes());
	    }

	 // set Node State (Opened , Closed) if provided
	    if(treeNodeCO.getNodeState() != null &&
		    (TreeNode.NODE_STATE_OPEN.equals(treeNodeCO.getNodeState())
			    ||   TreeNode.NODE_STATE_CLOSED.equals(treeNodeCO.getNodeState())))
	    {
		node.setState(treeNodeCO.getNodeState());
	    }
	    else
	    {
		node.setState(defualtNodesState);
	    }

	    // Add node to the map
	    nodesMap.put(node.getNodeCode(), node);
	}

	for(Map.Entry<String, TreeNode> entry : nodesMap.entrySet())
	{
	    // Check if this entry is the first level parent (parentCode is null
	    // or empty)
	    if(entry.getValue().getParentNodeCode() == null || entry.getValue().getParentNodeCode().isEmpty())
	    {
		continue;
	    }

	    // Search for my parent and add me to it
	    TreeNode parentNode = nodesMap.get(entry.getValue().getParentNodeCode());
	    if(parentNode != null)
	    {
		// Found my parent, then add me
		//nodesMap.get(entry.getValue().getParentNodeCode()).getChildren().add(entry.getValue());
		addNodeInCorrectOrder(nodesMap,entry.getValue());

		// mark the parent that it has a child
		nodesMap.get(entry.getValue().getParentNodeCode()).setHasChild(true);
		// if parent Node State not provided then set it as Opened
		if(parentNode.getState() == null)
		{
		    nodesMap.get(entry.getValue().getParentNodeCode()).setState(defualtNodesState);
		}

		// mark me that i am a child for a node
		entry.getValue().setaChild(true);
		// Temporary set me as leaf (if not specified). It will be overridden in case this
		// node has a child
		if(entry.getValue().getState() == null)
		{
		    entry.getValue().setState(TreeNode.NODE_STATE_LEAF);
		}
	    }

	}

	List<TreeNode> nodes = new ArrayList<TreeNode>(nodesMap.values());

	// Remove the nodes that are already children of another nodes
	// Note: used iterator.remove() to avoid ConcurrentModificationException
	Iterator<TreeNode> iterator = nodes.iterator();
	while(iterator.hasNext())
	{
	    TreeNode treeNode = iterator.next();
	    if(treeNode.isaChild())
	    {
		iterator.remove();
	    }
	    if(!treeNode.isHasChild())
	    {
		treeNode.setState(TreeNode.NODE_STATE_LEAF);
	    }
	}

	return nodes;
    }
    /**
     * Method to put the CHild in correct order in the parent Node
     * @param nodesMap Map of the Tree Nodes
     * @param theNode Current Map
     */
    private void addNodeInCorrectOrder(Map<String, TreeNode> nodesMap, TreeNode theNode) 
    {
	List<TreeNode> nodeChildren = nodesMap.get( theNode.getParentNodeCode()).getChildren();
	// children should not be null but in case it occurs
	if(nodeChildren != null)
	{
	 // no children added yet 
	    if(nodeChildren.size() == 0)
	    {
		nodeChildren.add(theNode);
	    }
	    else
	    {
		Integer theCurrNodeOrder = theNode.getNodeOrder();
		// no order specified
		if(theCurrNodeOrder == null)
		{
		    nodeChildren.add(theNode);
		}
		else
		{
		    Iterator<TreeNode> iterator = nodeChildren.iterator();
		    Integer childNodeOrder ;
		    int childPos = 0; boolean noChildAdded = true;
		    while(iterator.hasNext())
		    {
			childNodeOrder = iterator.next().getNodeOrder();
			// if child order is null then consider it as very big number just for comparison
			childNodeOrder = childNodeOrder == null? 100000000 : childNodeOrder;
			if(theCurrNodeOrder < childNodeOrder)
			{
			    nodeChildren.add(childPos,theNode);
			    noChildAdded = false;
			    break;
			}
			childPos++;
		    }
		    
		    // check if child is not added yet and it has order then add it to the reached position
		    if(noChildAdded)
		    {
			nodeChildren.add(childPos,theNode);
		    }
		}
	    }
	}
	
    }

    /**
     * This method responsible of rendering graphical tree for <pgt:gtree /> tag
     * 
     * @param treeNodeCOs
     * @return
     */
    private String renderGraphicalTree(List<GraphicalNodeCO> gNodeCOs, List<GraphicalLinkCO> gLinkCOs)
    {
	List<GraphicalNode> graphElements = new ArrayList<GraphicalNode>();
	Map<String, GraphicalPattern>  graphicalPatterns = new HashMap<String, GraphicalPattern>();
	GraphicalNode graphicalNode;
	GraphicalNode linkNode;
	StringBuffer sb = new StringBuffer();
	try
	{
	    Map<String, Map<String,GraphicalLinkCO>> linksMap = null; 
	    if(gLinkCOs != null && !gLinkCOs.isEmpty())
	    {
		linksMap = new HashMap<String, Map<String,GraphicalLinkCO>>();
		for(GraphicalLinkCO linkCO : gLinkCOs)
		{
		    if(linksMap.containsKey(linkCO.getSourceId()))
		    {
			Map<String,GraphicalLinkCO> linkMap = linksMap.get(linkCO.getSourceId());
			linkMap.put(linkCO.getTargetId(), linkCO);
		    }
		    else
		    {
			Map<String,GraphicalLinkCO> linkMap = new HashMap<String, GraphicalLinkCO>();
			linkMap.put(linkCO.getTargetId(), linkCO);
			linksMap.put(linkCO.getSourceId(), linkMap);
		    }
		}
	    }
	    
	    for(GraphicalNodeCO co : gNodeCOs)
	    {
		if((co.getId() == null || co.getId().isEmpty()) || (co.getText() == null || co.getText().isEmpty()))
		{
		    throw new BaseException("Missing Required Attributes:"
			    + ((co.getId() == null || co.getId().isEmpty()) ? " id " : "")
			    + ((co.getText() == null || co.getText().isEmpty()) ? " text " : ""));
		}
		graphicalNode = new GraphicalNode(co.getId(), co.getParentId(), co.getFillColor(), getEscText(co
			.getText()), co.getTextColor(), co.getStrokeColor(), co.getLinkColor());
		// TODO check if there is a need to set the angle, width , ...
		if(co.getAngle() != null)
		{
		    graphicalNode.setAngle(co.getAngle());
		}
		if(co.getHeight() != null)
		{
		    graphicalNode.setHeight(co.getHeight());
		}
		if(co.getWidth() != null)
		{
		    graphicalNode.setWidth(co.getWidth());
		}
		if(co.getRx() != null)
		{
		    graphicalNode.setRx(co.getRx());
		}
		if(co.getRy() != null)
		{
		    graphicalNode.setRy(co.getRy());
		}
		if(co.getStrokeWidth() != null)
		{
		    graphicalNode.setStrokeWidth(co.getStrokeWidth());
		}
		if(co.getTextDiplayLength() != null)
		{
		    graphicalNode.setTextDiplayLength(co.getTextDiplayLength());
		}
		if(co.getCustomDetails() != null)
		{
		    graphicalNode.setCustomDetails(co.getCustomDetails());
		}
		if(co.getGraphicalPattern() != null && GraphicalNode.BG_IMAGE_PATTERN.equals(co.getGraphicalPattern().getPatternType()))
		{
		    graphicalNode.setUrlPattern(co.getGraphicalPattern().getPatternName());
		    graphicalPatterns.put(co.getGraphicalPattern().getPatternName(),co.getGraphicalPattern());
		}
		
		if(co.getPosX() != null && co.getPosY() != null)
		{
		    graphicalNode.setLoadPosition(true);
		    graphicalNode.setPosX(co.getPosX());
		    graphicalNode.setPosY(co.getPosY());
		}
		
		graphicalNode.populateNode();
		graphElements.add(graphicalNode);

		if(co.getParentId() != null && !co.getParentId().isEmpty())
		{
		    // create link
		    linkNode = new GraphicalNode(co.getParentId(), co.getId());
		    if(co.getLinkColor() != null && !co.getLinkColor().isEmpty())
		    {
			linkNode.setLinkColor(co.getLinkColor());
		    }
		    if(co.getLinkLabel() != null && !co.getLinkLabel().isEmpty())
		    {
			linkNode.setLinkLabel(co.getLinkLabel());
		    }
		    if(linksMap != null 
			    && linksMap.containsKey(co.getParentId()) 
			    && linksMap.get(co.getParentId()).containsKey(co.getId()))
		    {
			linkNode.setCustomDetails(linksMap.get(co.getParentId()).get(co.getId()).getCustomDetails()); 
		    }

		    initializeLinkVertices(co ,  linkNode);
		    
		    linkNode.populateNodesLink();
		    graphElements.add(linkNode);
		}
		
		if(co.getParentNodesList() != null && !co.getParentNodesList().isEmpty())
		{
		    for(GraphicalNodeCO parentNode : co.getParentNodesList())
		    {
			GraphicalNode parentLinkNode = new GraphicalNode(parentNode.getId(), co.getId());
			if(parentNode.getLinkColor() != null && !parentNode.getLinkColor().isEmpty())
			{
			    parentLinkNode.setLinkColor(parentNode.getLinkColor());
			}
			if(parentNode.getLinkLabel() != null && !parentNode.getLinkLabel().isEmpty())
			{
			    parentLinkNode.setLinkLabel(parentNode.getLinkLabel());
			}
			if(linksMap != null 
				    && linksMap.containsKey(parentNode.getId()) 
				    && linksMap.get(parentNode.getId()).containsKey(co.getId()))
			{
			    parentLinkNode.setCustomDetails(linksMap.get(parentNode.getId()).get(co.getId()).getCustomDetails()); 
			}
			
			initializeLinkVertices(parentNode ,  parentLinkNode);
			
			parentLinkNode.populateNodesLink();
			graphElements.add(parentLinkNode);
		    }
		}
		
	    }
	    sb.append("{\"cells\":");
	    sb.append(PathJSONUtil.serialize(graphElements, null, null, true, true));
	    if(graphicalPatterns != null && !graphicalPatterns.isEmpty())
	    {
		sb.append(",\"patterns\":");
	    	sb.append(PathJSONUtil.serialize(graphicalPatterns, null, null, true, true));
	    }
	    sb.append("}");

	}
	catch(JSONException e)
	{
	    handleException(e, "Error occured during serialzing the graphical nodes", null);
	}
	catch(BaseException exp)
	{
	    handleException(exp, null, null);
	}

	return sb.toString();
    }

    private void initializeLinkVertices(GraphicalNodeCO node, GraphicalNode linkNode)
    {
	if(StringUtil.isNotEmpty(node.getLinkVertices()))
	{
	    try
	    {
		ObjectMapper mapper = new ObjectMapper();
		mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
		GraphicalVertice[] vertices = (GraphicalVertice[]) mapper.readValue(node.getLinkVertices(),
			GraphicalVertice[].class);
		linkNode.setVertices(vertices);
	    }
	    catch(Exception e)
	    {
		log.error(e, "[renderGraphicalTree] Error while converting link vertices");
	    }
	}
    }
    
    /**
     * Generates auto ID for nodes
     * 
     * @return
     */
    private String autoGenerateNodeID()
    {
	return Long.toHexString(Double.doubleToLongBits(Math.random()));
    }

    /**
     * @return the nodes
     */
    public List<TreeNode> getNodes()
    {
	return nodes;
    }

    /**
     * @param nodes the nodes to set
     */
    public void setNodes(List<TreeNodeCO> treeNodeCOs)
    {
	this.nodes = generateTree(treeNodeCOs);
    }
  /**
   * Method to initialize the nodes of the tree with specific nodes state
   * @param treeNodeCOs nodes the nodes to set
   * @param defualtNodesState Default State of All Nodes that are Parents
   */
    public void setNodes(List<TreeNodeCO> treeNodeCOs, String defualtNodesState)
    {
	// by default, all nodes state is opened, unless specified differently by DEVELOPER
	if(defualtNodesState != null && TreeNode.NODE_STATE_CLOSED.equals(defualtNodesState))
	{
	    this.defualtNodesState = defualtNodesState;
	}
	setNodes(treeNodeCOs);
    }

    /**
     * @return the cells
     */
    public String getGraphCells()
    {
	return graphCells;
    }

    /**
     * @param cells the cells to set
     */
    public void setGraphCells(List<GraphicalNodeCO> cells)
    {
	this.graphCells = renderGraphicalTree(cells,null);
    }

    /**
     * @param cells the cells to set
     * @param links the links to set
     */
    public void setGraphCells(List<GraphicalNodeCO> cells, List<GraphicalLinkCO> links)
    {
	this.graphCells = renderGraphicalTree(cells,links);
    }
    
    /**
     * Set the graphCells from saved json string.
     * 
     * @param json
     */
    public void setGraphCellsFromJSON(String jsonGTree)
    {
	this.graphCells = jsonGTree;
    }
    
    /**
     * Function used to transform string data to GraphicalNodeCO array
     * for example String content = "[{\"type\":\"path.Rect\",\"position\":{\"x\":65,\"y\":0},\"size\":{\"width\":80,\"height\":60},\"angle\":0,\"id\":\"0\",\"z\":1},{\"type\":\"path.Rect\",\"position\":{\"x\":0,\"y\":90},\"size\":{\"width\":80,\"height\":60},\"angle\":0,\"customDetails\":\"aaaaaa\",\"id\":\"1\",\"z\":1,\"parentNodesList\":[{\"parentId\":\"0\"}]},{\"type\":\"path.Rect\",\"position\":{\"x\":130,\"y\":90},\"size\":{\"width\":80,\"height\":60},\"angle\":0,\"customDetails\":\"bbbb\",\"id\":\"2\",\"z\":1,\"parentNodesList\":[{\"parentId\":\"0\"}]},{\"type\":\"path.Rect\",\"position\":{\"x\":30,\"y\":180},\"size\":{\"width\":80,\"height\":60},\"angle\":0,\"id\":\"3\",\"z\":1,\"parentNodesList\":[{\"parentId\":\"2\"},{\"parentId\":\"1\"}]},{\"type\":\"path.Rect\",\"position\":{\"x\":65,\"y\":270},\"size\":{\"width\":80,\"height\":60},\"angle\":0,\"id\":\"4\",\"z\":1,\"parentNodesList\":[{\"parentId\":\"2\"},{\"parentId\":\"3\"}]}]";
     * @param content
     * @return
     */
    public GraphicalNodeCO[] returnTreeNodes(String content)
    {
	try
	{
	    ObjectMapper mapper = new ObjectMapper(); 
	    mapper.setVisibility(JsonMethod.ALL, Visibility.NONE);
	    mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);
	    mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
	    return mapper.readValue(content, GraphicalNodeCO[].class);
	}
	catch(Exception e)
	{
	    handleException(e, "Error occured during returning tree nodes", null);
	}
	return null;
    }
    
    /**
     * Function used to transform string data to GraphicalLinkCO array
     * for example String content = "[{"sourceId":"0","targetId":"1"},{"sourceId":"2","targetId":"4"},{"sourceId":"3","targetId":"4"},{"sourceId":"0","targetId":"2"},{"sourceId":"2","targetId":"3"},{"sourceId":"1","targetId":"3"},{"sourceId":"1","targetId":"4","customDetails":"{\"aaa\":\"bbb\"}"}]"
     * @param content
     * @return
     */
    public GraphicalLinkCO[] returnTreeLinks(String content)
    {
	try
	{
	    ObjectMapper mapper = new ObjectMapper(); 
	    mapper.setVisibility(JsonMethod.ALL, Visibility.NONE);
	    mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);
	    mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
	    return mapper.readValue(content, GraphicalLinkCO[].class);
	}
	catch(Exception e)
	{
	    handleException(e, "Error occured during returning tree nodes", null);
	}
	return null;
    }

}
